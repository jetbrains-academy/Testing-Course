<h2>Плюсы наследования: магия ООП</h2>

<p>Если вы использовали ранее парадигму ООП при написании кода, то уже представляете, как хорошая архитектура может облегчить жизнь. В этом плане код автотестов ничем не отличается от кода приложений &mdash; мы можем использовать всё те же приёмы для организации методов.</p>

<p>Здесь мы рассмотрим лишь один из примеров: использование механизма наследования.</p>

<p>Мы уже немного использовали механизм наследования, когда сделали базовый класс для всех наших проверок BasePage, а от него наследовали&nbsp;все остальные Page Object: LoginPage, MainPage. Сейчас у нас в классе BasePage в основном технические детали &mdash; реализация поиска элементов, метод для открытия страницы и прохождения капчи. Но никто не мешает нам добавить туда элементы и методы, которые являются общими для всех страниц.</p>

![pages (1).svg](pages%20%281%29.svg)
<h3>&nbsp;</h3>

<p><strong>ВАЖНО! </strong>Не нужно запихивать в базовый класс все, что плохо лежит и может когда-нибудь пригодиться. Добавлять нужно только то, что ОБЯЗАТЕЛЬНО будет на каждой странице-наследнике, иначе есть риск, что увеличение строк кода в файле&nbsp;будет неконтролируемым,&nbsp;и поддерживать его будет сложно.</p>

<p>Вообще говоря, мы можем строить какую угодно иерархию наших классов для взаимодействия с веб-приложением, если это поможет избежать дублирования кода. Например, есть набор страниц с общими методами, мы можем организовать их в виде наследования с дополнительным &quot;слоем&quot;.</p>

<p>Например, когда мы тестируем страницу урока в Hyperskill,&nbsp;мы используем LessonPage как базовый класс, где содержатся общие элементы и методы для всех типов шагов (шапка, боковое расписание) и класс-наследник для каждого типа заданий.&nbsp;Такой подход&nbsp;позволяет избежать дублирования кода,&nbsp;и необходимости поддерживать файл на &gt;1000 строк кода.&nbsp;</p>

![pages2 (1).svg](pages2%20%281%29.svg)